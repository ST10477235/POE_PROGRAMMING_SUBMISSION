/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.mycompany.portfolio_of_evidence_poe;
import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import javax.swing.JOptionPane;
import java.util.Map;
/**
 *
 * @author VUNINI
 */

//overrides relying on public getters and setters for JSON processing, enables access to all fields, and ensures that all fields are included in the JSON output, even if they donâ€™t have public access modifiers.
@JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)
public class Message {
    //Attributes
    //add @JsonProperty to instance fields to ensures Jackson properly serializes them
        @JsonProperty("messageId")
        private String messageId;
        @JsonProperty("recipient")
        private String recipient;
        @JsonProperty("messageText")
        private String messageText;
        //Static fields dont need annotation as there are not sterialized in JSON by default 
        private static int totalMessages = 0;
        @JsonProperty("messageNumber")
         int messageNumber;
        private String createdMessageHash;
        //storing all the messages
        int countMessages = 1;
    private final ObjectMapper mapper = new ObjectMapper();
    private final ArrayNode messagesArray = mapper.createArrayNode(); // Runtime-only storage
    static List<String> messageSentList = new ArrayList<>();
    static List<String> messageDiscardedList = new ArrayList<>();
    static List<String> messageIdList = new ArrayList<>();
    static List<String> messageHashList = new ArrayList<>();
    static List<String> storedMessagesList = new ArrayList<>(); 
    static List<String> recipients = new ArrayList<>();
    private static List<String> masterMessageList = new ArrayList<>();

//Constructors
    public Message(String recipient)
    {
        this.recipient = recipient;
        this.messageText = "";
        this.messageId = "";
    //Refined my code by removing the if statement that displays "Invalid message Id generated" when it returns to be false 
    }

    // Message class methods 
    
    //I kept the for loop so that i dont repeat "messageId.append(random.nextInt(10))" 9 times 
    String generateMessageId()
    {
        //I created a random instance(new Random)to generate new numbers  
        Random random = new Random();
        //Initiallizing the StringBuilder to store the  generated messageId
        StringBuilder messageId = new StringBuilder();
        messageId.append(random.nextInt(9)+1);//Generates 1-9
        for(int i=1;i<10;i++)
        {
          messageId.append(random.nextInt(10));//Generate 0-9
        }
        System.out.println("Message ID generated: " + messageId);
        // the generated number 0,9,8,7,6,5,4,3,2,1 will be "0987654321"
        return messageId.toString();
    }
    //This method checks if message id is 10 digits long and contains numerical values 
    
    public boolean checkMessageId(String messageId)
    {
        return messageId.length() == 10 && messageId.matches("\\d+");
    }
    //Removed the nested if statement that handles null pointers errors and the cellphone requirements by making it one return statement.This made my methods intend strate forward   
    
    public int checkRecipientCell ()
    {
        //parenthesis play a vey important role here before the second set of parenthesis my program's build would fail if i press "X" when asked to enter recipient number    
        return (recipient != null && (recipient.matches("\\+27\\d{9}")|| recipient.matches("0\\d{9}"))? 1 : 0 );
        //this first checks the and operator as it has higher precedence meaning the or system will first check if its not empty and if not it will check for either a number that starts with +27 or 0 and ensures that number following that are exactly 9 digits       
    }
   
    //Creating and return an autogenerated message hash which has first 2 numbers of message id , the number of messages , the first and last words in the message in uppercases  
    public String createMessageHash(int messageNumber)
    {
        System.out.println("Received Message Number: " + countMessages);
        String validMessageId = (messageId != null && messageId.length()>=2)?messageId.substring(0, 2):"Invalid";
        String [] words = messageText.split("\\s+");
        String firstWord = (words.length>0)? words [0].toUpperCase():"Empty";
        String lastWord = (words.length>1)?words[words.length-1].toUpperCase(): firstWord;
        createdMessageHash = validMessageId + ":" + messageNumber + ":" + firstWord + lastWord; 
       System.out.println("Created Message Hash: " + createdMessageHash); 
        return createdMessageHash;
    }
    
    //Method to select send , store or discard message removed it from the main program to here and called the method instaed 
    public String sendMessage() {
    String[] buttonOptions = {
        "Send message",
        "Disregard message",
        "Store message to send later"
    };

    String[] responseMessages = {
        "Message sent successfully",
        "Message discarded",
        "Message stored sucessfully to JSON file"
    };

    int option = JOptionPane.showOptionDialog(
        null, 
        "What would you like to do with the message?", 
        "Message Option", 
        JOptionPane.DEFAULT_OPTION, 
        JOptionPane.QUESTION_MESSAGE, 
        null, 
        buttonOptions, 
        buttonOptions[0]
    );

   return (option == JOptionPane.CLOSED_OPTION)?null:responseMessages[option]; 
    }
 
    //Initially this was my sendMessage method which did not allow the user to make choices then i change the name and still used it to check the length and display appropriate messages depending on the condition 
    public String validateMessageLength(String messageText)//*
    {
        //I then combined the two returns with if statements using ? and : to check the messages validation 
        return messageText.length()>250 ? "Please enter message of less than 250 characters":"Message sent successfully";
    }
    
    //This method returns a list of all the messages sent 
    public static List<String> printSentMessages()
    {
        List<String>sentMessages = new ArrayList<>();
        return sentMessages;
    }
     
    //Displays the full detailes regarding the message this includes the message id , hash , actual text and the person who will recieve that message  
    public String printFullDetails(int messageNumber)//*
    {
        messageNumber++;
        return "Message ID:"+messageId
                +"\n Message Hash:"+createMessageHash(messageNumber)//calling the method hence its not a keyword because its not a field rather a method i created  
                +"\nRecipient:"+recipient 
                +"\nMessage:"+messageText;
    }
    
    //This method is to ensure that the total number of messages sent is returned , without this method there will be errors so returning , incrementing and reseting the total messages is very efficient to avoid logical errors  
    public static int returnTotalMessages()
    {
       return totalMessages;
    }
   
    //Total messages sent are acumulated in this case when you're about to send a message since its set to 0 when you send it will be 1 everytime a message is send the it counts from the initial value to the end 
    public static void incrementTotalMessages() 
    {
       totalMessages++;
    }
    
    //without this method when i run my code the first time it would be correct but the second time it will display total number including the first one hence i had to create a variable to reset it every time when i am done entering messages  
    public static void resetTotalMessages()
    {
      totalMessages = 0;
    }
   
public void storeMessageToFile(String messageText) {
    if (messageText.trim().isEmpty()) {
        System.out.println("DEBUG: Skipping empty message.");
        return; 
    }

    ObjectNode newMessage = mapper.createObjectNode();
    newMessage.put("message", messageText);
    messagesArray.add(newMessage);
    storedMessagesList.add(messageText);

    ObjectNode finalJson = mapper.createObjectNode();
    finalJson.set("messages", messagesArray);

    try (FileWriter writer = new FileWriter("messages.txt", false)) {
        for (String msg : storedMessagesList) {
            writer.write(msg + "\n"); 
        }
        writer.flush();
    } catch (IOException e) {
        System.out.println("Error writing message to file: " + e.getMessage());
    }

    File file = new File("messages.txt");
    System.out.println("DEBUG: File Exists? -> " + file.exists());
    System.out.println("DEBUG: File Size -> " + file.length());

    try {
        System.out.println(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(finalJson));
    } catch (Exception e) {
        System.out.println("Error generating JSON: " + e.getMessage());
    }
}

public void readStoredMessagesFromFile() {
    List<String> fileMessages = new ArrayList<>();

    try (BufferedReader reader = new BufferedReader(new FileReader("messages.txt"))) {
        String line;
        while ((line = reader.readLine()) != null) {
            fileMessages.add(line);
        }
    } catch (IOException e) {
        System.out.println("Error reading stored messages from file: " + e.getMessage());
        return;
    }

    System.out.println("DEBUG: Raw Messages Read from File -> " + fileMessages);
    
    if (fileMessages.isEmpty()) {
        System.out.println("No stored messages found.");
        return;
    }

  
    String formattedMessages = "{ " + String.join(", ", fileMessages) + " }";
    System.out.println(formattedMessages);
}
//METHOD TO DISPLAY SENDER AND RECIPIENT OF ALL MESSAGES ACROSS THE LIST TO BE USED IN MESAGE_ARRAYMETHODS FOR UNIT TESTING
public static void displayMessages(String cellPhoneNumber, 
                                  Map<String, List<String>> recipientMessageMap, 
                                  List<String> messageSentList, List<String> storedMessagesList, 
                                  List<String> messageDiscardedList) {
    StringBuilder messageDisplay = new StringBuilder("All Messages:\n");

    for (Map.Entry<String, List<String>> entry : recipientMessageMap.entrySet()) {
        String recipient = entry.getKey();
        List<String> messages = entry.getValue();

        for (String message : messages) {
            String status = messageSentList.contains(message) ? "Sent" :
                            storedMessagesList.contains(message) ? "Stored" :
                            messageDiscardedList.contains(message) ? "Discarded" : "Unknown";

            messageDisplay.append("Sender: ").append(cellPhoneNumber)
                    .append(" | Recipient: ").append(recipient)
                    .append(" | Message: \"").append(message)
                    .append("\" | Status: [").append(status).append("]\n");
        }
    }

    JOptionPane.showMessageDialog(null, messageDisplay.toString(), "Message Log", JOptionPane.INFORMATION_MESSAGE);
}
//METHOD TO DISPLAY THE LONGEST MESSAGES ACROSS THE LIST TO BE USED IN MESAGE_ARRAYMETHODS FOR UNIT TESTING
public static void displayLongestSentMessage(List<String> messageSentList, 
                                             List<String> storedMessagesList, 
                                             List<String> messageDiscardedList) {
    if (messageSentList.isEmpty() && storedMessagesList.isEmpty() && messageDiscardedList.isEmpty()) {
        System.out.println("DEBUG: No messages found in any list!");
        JOptionPane.showMessageDialog(null, "No messages available.", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }

    String longestSentMessage = findLongestMessage(messageSentList);
    String longestStoredMessage = findLongestMessage(storedMessagesList);
    String longestDiscardedMessage = findLongestMessage(messageDiscardedList);

    System.out.println("DEBUG: Longest Sent Message -> " + longestSentMessage);
    System.out.println("DEBUG: Longest Stored Message -> " + longestStoredMessage);
    System.out.println("DEBUG: Longest Discarded Message -> " + longestDiscardedMessage);

    JOptionPane.showMessageDialog(null, 
        "Longest Sent Message: " + longestSentMessage + "\n" +
        "Longest Stored Message: " + longestStoredMessage + "\n" +
        "Longest Discarded Message: " + longestDiscardedMessage,
        "Longest Messages Across Lists", JOptionPane.INFORMATION_MESSAGE);
}
// HELPER METHOD TO FIND THE LONGEST MESSAGES ACROSS ALL LISTS
static String findLongestMessage(List<String> messages) {
    if (messages.isEmpty()) return "No messages in this list";

    String longestMessage = "";
    for (String message : messages) {
        if (message.length() > longestMessage.length()) {
            longestMessage = message;
        }
    }
    return longestMessage;
}
//HELPER METHOD THAT UPDATED THE MASTER EVERYTIME AN ACTION IS TAKEN 
public static void updateMasterList(List<String> messageIdList, 
                                    List<String> storedMessagesList, 
                                    List<String> messageSentList, 
                                    List<String> messageDiscardedList) {
    masterMessageList.clear();

    for (String messageId : messageIdList) {
        String messageText = "Unknown Message";

        int storedIndex = storedMessagesList.indexOf(messageId);
        int sentIndex = messageSentList.indexOf(messageId);
        int discardedIndex = messageDiscardedList.indexOf(messageId);

        if (storedIndex != -1) {
            messageText = storedMessagesList.get(storedIndex);
        } else if (sentIndex != -1) {
            messageText = messageSentList.get(sentIndex);
        } else if (discardedIndex != -1) {
            messageText = "Discarded Message";
        }

        masterMessageList.add(messageText); 
    }

}
//METHOD TO SEARCH AND DISPLAY ALL MESSAGES TO A PARTICULAR RECIPIENT TO BE USED IN MESAGE_ARRAYMETHODS FOR UNIT TESTING
public static void searchMessagesForRecipient(Map<String, List<String>> recipientMessageMap, String searchedRecipient) {
    System.out.println("DEBUG: Searching for recipient -> " + searchedRecipient);
    System.out.println("DEBUG: Current recipient-message map before search -> " + recipientMessageMap);

    if (!recipientMessageMap.containsKey(searchedRecipient)) {
        JOptionPane.showMessageDialog(null, "Recipient not found!");
        System.out.println("DEBUG: Recipient " + searchedRecipient + " is NOT stored in recipientMessageMap.");
        return;
    }

    List<String> messages = recipientMessageMap.get(searchedRecipient);
    System.out.println("DEBUG: Retrieved Messages for " + searchedRecipient + " -> " + messages);

    if (messages.isEmpty()) {
        JOptionPane.showMessageDialog(null, "No messages found for " + searchedRecipient);
        System.out.println("DEBUG: Recipient exists but has NO messages linked.");
    } else {
        JOptionPane.showMessageDialog(null, "Messages for " + searchedRecipient + ":\n" + String.join("\n", messages));
        System.out.println("DEBUG: Messages successfully retrieved and displayed.");
    }
}
//METHOD TO DISPLAY SEARCH MESSAGES USING MESSAGE ID TO BE USED IN MESAGE_ARRAYMETHODS FOR UNIT TESTING
public static void searchMessageById(String messageId, String recipient, List<String> messageIdList, List<String> masterMessageList) {
    messageId = messageId.trim();
    String matchedMessage = "Unknown Message";

    System.out.println("DEBUG: Searching for Message ID -> " + messageId);
    System.out.println("DEBUG: Message ID List -> " + messageIdList);

    int foundIndex = messageIdList.indexOf(messageId);
    System.out.println("DEBUG: Found Index -> " + foundIndex);

    if (foundIndex == -1 || foundIndex >= messageIdList.size()) {
        System.out.println("DEBUG: Message ID not found!");
        JOptionPane.showMessageDialog(null, "Message ID not found.", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }

    if (foundIndex < masterMessageList.size()) {
        matchedMessage = masterMessageList.get(foundIndex);
        System.out.println("DEBUG: Message retrieved -> " + matchedMessage);
    } else {
        System.out.println("DEBUG: Message not found.");
    }

    System.out.println("DEBUG: Retrieved Recipient -> " + recipient);

    JOptionPane.showMessageDialog(null, 
        "Recipient: " + recipient + "\nMessage: " + matchedMessage, 
        "Message Details", JOptionPane.INFORMATION_MESSAGE);
}
//METHOD TO DELETE MESSAGE USING MESSAGE HASH TO BE USED IN MESAGE_ARRAYMETHODS FOR UNIT TESTING
public static void deleteMessageByHash(String messageHash, 
                                       List<String> messageIdList, 
                                       List<String> messageSentList, 
                                       List<String> storedMessagesList, 
                                       List<String> messageDiscardedList, 
                                       List<String> messageHashList,
                                       List<String> masterMessageList) {
    System.out.println("DEBUG: Searching for Message Hash -> " + messageHash);
    messageHash = messageHash.trim();

    int index = messageHashList.indexOf(messageHash);
    System.out.println("DEBUG: Found index -> " + index);
    //INDEX IS NOT 1 MEANS FOUND
    if (index != -1) { 
        System.out.println("DEBUG: Deleting message associated with Hash -> " + messageHash);

        String messageToDelete = masterMessageList.get(index);

        masterMessageList.remove(messageToDelete);
        messageSentList.remove(messageToDelete);
        storedMessagesList.remove(messageToDelete);
        messageDiscardedList.remove(messageToDelete);
        messageIdList.remove(index);
        messageHashList.remove(index);

        System.out.println("DEBUG: Message successfully deleted.");
        JOptionPane.showMessageDialog(null, "Message deleted successfully.", "Success", JOptionPane.INFORMATION_MESSAGE);
        
        System.out.println("DEBUG: Updated Master Message List -> " + masterMessageList);
        System.out.println("DEBUG: Updated Message ID List -> " + messageIdList);
        System.out.println("DEBUG: Updated Message Sent List -> " + messageSentList);
        System.out.println("DEBUG: Updated Stored Messages List -> " + storedMessagesList);
        System.out.println("DEBUG: Updated Message Discarded List -> " + messageDiscardedList);
        System.out.println("DEBUG: Updated Message Hash List -> " + messageHashList);
        
    } else {
        System.out.println("DEBUG: Message Hash NOT found!");
        JOptionPane.showMessageDialog(null, "Message Hash not found.", "Error", JOptionPane.ERROR_MESSAGE);
    }

    
}
//METHOD TO DISPLAY FULL DETAILS REPORT TO BE USED IN MESAGE_ARRAYMETHODS FOR UNIT TESTING
public static String displayFullDetails(
        String recipient, 
        List<String> messageIdList, 
        List<String> messageHashList, 
        List<String> masterMessageList, 
        Map<String, List<String>> recipientMessageMap) {

    StringBuilder report = new StringBuilder();

    report.append("********************************************************************************\n");
    report.append("               FULL MESSAGE REPORT                                              \n");
    report.append("******************************************************************************\n\n");

    List<String> messages = recipientMessageMap.get(recipient);

    if (messages != null && !messages.isEmpty()) {
        for (String message : messages) {
            int index = masterMessageList.indexOf(message);
            if (index != -1) {
                report.append("MESSAGE ID        :  ").append(messageIdList.get(index)).append("\n");
                report.append("MESSAGE HASH      :  ").append(messageHashList.get(index)).append("\n");
            }

            report.append("RECIPIENT         :  ").append(recipient).append("\n");
            report.append("MESSAGE           :  ").append(message).append("\n");
            report.append("**************************************************************************\n\n");
        }
    } else {
        report.append("No messages found for recipient: ").append(recipient).append("\n");
        report.append("**************************************************************************\n\n");
    }

    report.append("                End of Report                                                   \n");
    report.append("********************************************************************************\n");

    JOptionPane.showMessageDialog(null, report.toString(), "Full Message Details Report", JOptionPane.INFORMATION_MESSAGE);
    return report.toString();
}

    //Setters and Getters 
    public String getMessageId(){
        return messageId;
    }
    public String getRecipient(){
        return recipient;
    }
    public String getMessageText(){
        return messageText;
    }
    public String getCreatedMessageHash()
    {
        return createdMessageHash;
    }
    public int getMessageNumber() {
    return messageNumber;
    }
    public void setMessageText(String messageText) 
    {
        this.messageText = messageText;

        if (!messageText.isEmpty()&& messageId.isEmpty()) {
            this.messageId = generateMessageId(); 
        }
    }
    public void setCreatedMessageHash(String hash) {
    this.createdMessageHash = hash;
}
    void setMessageId(String string) 
    {
     
    }
    //USEFULL IN UNIT TESTING   
    Message() 
    {
     
    }
   
}

   
 


    

